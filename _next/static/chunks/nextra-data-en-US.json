{"/code-generation/advanced-features":{"title":"Advanced Features","data":{"advanced-features#Advanced Features":"","custom-actions#Custom Actions":"You can specify which CRUD actions to generate using the --actions flag:\nnode ace dreamer posts --actions=index,show\nAvailable actions:\nindex (List all)\nshow (View single)\nstore (Create)\nupdate (Edit)\ndestroy (Delete)","nested-resources#Nested Resources":"Dreamer supports nested resource generation for related entities. This is particularly useful for parent-child relationships:\nnode ace dreamer posts/comments\nNote: Currently, dreamer doesn't have the capacity to determine relationships."}},"/code-generation/basic-usage":{"title":"Basic Usage","data":{"code-generation#Code generation":"Dreamer has a powerful code generation tool that automates the creation of complete CRUD operations from a single migration file. This streamlines your development process by generating all necessary components with minimal configuration.","basic-usage#Basic Usage":"To generate a new CRUD, use the following command:\nnode ace dreamer [entity]\nReplace [entity] with your desired entity name. For example, to create a CRUD for blog posts:\nnode ace dreamer posts","workflow#Workflow":"The command creates a migration file\nYou'll be prompted to edit the file and define your entity fields\nAfter saving, Dreamer automatically generates all CRUD components","generated-components#Generated Components":"Dreamer creates a complete set of files for your entity:\napp/\n├── models/\n│   └── post.ts\n├── controllers/\n│   └── posts_controller.ts\n├── validators/\n│   └── post.ts\n├── routes/\n│   └── posts.ts\n└── docs/  # If Bruno is enabled\n    └── posts/\n        └── index.bru\n        └── show.bru\n        └── store.bru\n        └── update.bru\n        └── destroy.bru\nModel: Lucid model with all field definitions\nController: RESTful actions implementation\nValidators: Input validation rules for store and update actions\nRoutes: API endpoint definitions\nAPI Documentation: Automatically generated if Bruno is enabled in your configuration"}},"/code-generation/notes":{"title":"Notes","data":{"notes#Notes":"The code generated by Dreamer is 100% compatible with AdonisJS 6 development standards. While Dreamer's primary goal is to provide abstractions for common CRUD workflows to speed up development, it's designed to work seamlessly alongside traditional AdonisJS development patterns.You can:\nUse Dreamer's abstractions for standard CRUD operations\nCreate custom actions for complex scenarios using regular AdonisJS patterns\nMix both approaches in the same controller\nExtend or override Dreamer's generated code using standard AdonisJS features\nFor example:\nimport Post from '#models/post'\nimport { index, show, destroy } from '@oniryk/dreamer/extensions/crud'\nexport default class PostsController {\n  // Using Dreamer's abstractions for standard operations\n  public index = index(Post)\n  public show = show(Post)\n  public destroy = destroy(Post)\n  // Custom action for complex business logic\n  public async publish({ params, response }: HttpContext) {\n    const post = await Post.findOrFail(params.id)\n    await post.merge({\n      status: 'published',\n      publishedAt: new Date()\n    }).save()\n    await Event.emit('post:published', post)\n    return response.status(200).send(post)\n  }\n}\nThis flexibility allows you to leverage Dreamer's convenience while maintaining the freedom to implement custom business logic when needed."}},"/extensions/crud":{"title":"Crud","data":{"crud-operations#CRUD Operations":"The package provides pre-built CRUD operations that can be easily integrated into your controllers. All operations take a model as the first argument and offer some options depending on your functionality.This is a basic example of a complete RESTful controller:\nimport Post from '#models/post'\nimport { index, show, store, update, destroy } from '@oniryk/dreamer/extensions/crud'\nimport { validatePostCreate, validatePostUpdate } from '#validators/post'\nimport csv from '@oniryk/dreamer-csv'\nexport default class PostsController {\n  public index = index(Post)\n  public show = show(Post)\n  public store = store(Post, validatePostCreate)\n  public update = update(Post, validatePostUpdate)\n  public destroy = destroy(Post)\n}","index#index":"The index method provides a flexible way to list and filter records.\nimport { index } from '@oniryk/dreamer/extensions/crud'\nimport csv from '@oniryk/dreamer-csv'\nimport { validatePostIndex } from '#validators/post'\nexport default class PostsController {\n  public index = index(Post, {\n    perPage: 20,\n    formats: [csv()],\n    scope: 'highlights',\n    validator: validatePostIndex\n  })\n}\nOption\tType\tDescription\tperPage\tnumber\t(optional) Number of records per page\tformats\tOutputFormatFn[]\t(optional) Array of formatters to enable alternative output formats. When a format is added, the user can request the content in a format by passing f or format in the query string:Ex: GET /posts?f=csv\tscope\tstring | function\t(optional) Name of model scope to apply or function compatible with withScopes method of Lucid query builderEx: (scopes) => scopes.highlights()\tvalidator\tVineValidator\t(optional) Vine validation schema for query parameters","show#show":"The show method provides a way to retrieve a single record. When using UUID extension, it automatically handles UUID-based lookups.\nimport Post from '#models/post'\nimport { show } from '@oniryk/dreamer/extensions/crud'\nexport default class PostsController {\n  public show = show(Post)\n}\nOption\tType\tDescription\tmodel\tBaseModel\tThe Lucid model class","store#store":"The store method handles record creation with validation and optional data mutation.\nimport Post from '#models/post'\nimport { store } from '@oniryk/dreamer/extensions/crud'\nimport { validatePostUpdate } from '#validators/post'\nexport default class PostsController {\n  public store = store(Post, validatePostUpdate, {\n    mutate (row, payload) {\n      row.title = payload.title.toLowerCase()\n    }\n  })\n}\nParameter\tType\tDescription\tmodel\tBaseModel\tThe Lucid model class\tvalidator\tVineValidator\tVine validator schema for input validation\toptions.mutate\t(row: Model, payload: any) => void | Promise<void>\t(optional) Callback to modify data before saving","update#update":"The update method handles record updates with validation and optional data mutation.\nimport Post from '#models/post'\nimport { update } from '@oniryk/dreamer/extensions/crud'\nimport { validatePostUpdate } from '#validators/post'\nexport default class PostsController {\n  public update = update(Post, validatePostUpdate, {\n    mutate (row, payload) {\n      row.title = payload.title.toLowerCase()\n    }\n  })\n}\nParameter\tType\tDescription\tmodel\tBaseModel\tThe Lucid model class\tvalidator\tVineValidator\tVine validator schema for input validation\toptions.mutate\t(row: Model, payload: any) => void | Promise<void>\t(optional) Callback to modify data before saving","destroy#destroy":"The destroy method handles record deletion with proper error handling.\nimport Post from '#models/post'\nimport { destroy } from '@oniryk/dreamer/extensions/crud'\nexport default class PostsController {\n  public destroy = destroy(Post)\n}\nParameter\tType\tDescription\tmodel\tBaseModel\tThe Lucid model class"}},"/extensions/json-formatter":{"title":"Json Formatter","data":{"json-response-formatters#JSON Response Formatters":"JSON response formatters provide a consistent way to structure your API responses. They help maintain a uniform pattern for success and error across all your routes.","success#success":"The success method formats successful responses, supporting both simple and paginated data. It automatically structures the response with an \"ok\" status and includes the provided data, along with pagination metadata when applicable.Example 1: Simple List Response\nimport Post from '#models/post'\nimport { HttpContext } from '@adonisjs/core/http'\nimport { success } from '@oniryk/dreamer/extensions/http'\nexport default class PostsController {\n  public async list({ response }: HttpContext) {\n    const posts = await Post.all()\n    success(response, posts)\n  }\n}\n// Response:\n{\n  \"status\": \"ok\",\n  \"data\": [ ... ]\n}\nExample 2: Paginated Response\nexport default class PostsController {\n  public async paginated({ response, request }: HttpContext) {\n    const page = request.input('page', 1);\n    const limit = 20;\n    const posts = await Post.paginate(page, limit)\n    success(response, posts)\n  }\n}\n// Response:\n{\n  \"status\": \"ok\",\n  \"data\": [ ... ],\n  \"meta\": {\n    \"currentPage\": 1,\n    \"firstPage\": 1,\n    \"firstPageUrl\": \"/?page=1\",\n    \"lastPage\": 1,\n    \"lastPageUrl\": \"/?page=1\",\n    \"nextPageUrl\": null,\n    \"perPage\": 10,\n    \"previousPageUrl\": null,\n    \"total\": 6\n  }\n}","error#error":"The error method standardizes error handling in the API, providing a consistent structure for different types of errors. It can handle validation errors, custom errors, and standard system exceptions.Example 1: Validation Error Handling\nimport Post from '#models/post'\nimport { HttpContext } from '@adonisjs/core/http'\nimport { error } from '@oniryk/dreamer/extensions/http'\nimport { validatePostCreate } from '#validators/post'\nexport default class PostsController {\n  public async store({ response, request }: HttpContext) {\n    try {\n      await request.validate(validatePostCreate)\n    } catch (e) {\n      error(response, e);\n    }\n  }\n}\n// Response:\n{\n  \"status\": \"error\",\n  \"error\": {\n    \"code\": \"VALIDATION_ERROR\",\n    \"message\": \"Validation failure\",\n    \"issues\": [\n       {\n         \"field\": \"title\",\n         \"message\": \"The title field must be defined\",\n         \"rule\": \"required\"\n       }\n    ]\n  }\n}\nExample 2: Standard Error Response\nexport default class PostsController {\n  public async check ({ response, request }: HttpContext) {\n    if (1 === 1) {\n      error(response, new Error('invalid option'));\n    }\n  }\n}\n// Response:\n{\n  \"status\": \"error\",\n  \"error\": {\n    \"code\": \"Error\",\n    \"message\": \"invalid option\"\n  }\n}\nExample 3: Custom Error Response\nexport default class PostsController {\n  public async check2 ({ response, request }: HttpContext) {\n    if (1 === 1) {\n      error(response, { code: 'ERROR_CODE', message: 'invalid option'});\n    }\n  }\n}\n// Response:\n{\n  \"status\": \"error\",\n  \"error\": {\n    \"code\": \"ERROR_CODE\",\n    \"message\": \"invalid option\"\n  }\n}"}},"/extensions/lucid":{"title":"Lucid","data":{"lucid-extensions#Lucid Extensions":"","uuid-support#UUID Support":"The withUUID extension adds UUID support to your models. It's based on the concept of using UUID as a key to expose externally while keeping an autoincrementing integer as the primary key.\nimport { BaseModel } from '@adonisjs/lucid/orm'\nimport { compose } from '@adonisjs/core/helpers'\nimport { withUUID } from '@oniryk/dreamer/extensions/lucid'\nexport default class Post extends compose(BaseModel, withUUID()) {\n  //...\n}\nWhat's changed under the hood?\nid column keeps existing as primary key to speed up relationship queries\nuuid column is defined and autogenerates UUIDs for new records\nchanges the default behavior of find and findOrFail methods to use the uuid column instead of id when making queries","soft-delete-support#Soft-delete Support":"The withSoftDelete extension implements soft delete functionality in your models:\nAdds a deletedAt timestamp column to your model\nAutomatically filters out soft-deleted records from queries\nimport { BaseModel } from '@adonisjs/lucid/orm'\nimport { compose } from '@adonisjs/core/helpers'\nimport { withSoftDelete } from '@oniryk/dreamer/extensions/lucid'\nexport default class Post extends compose(BaseModel, withSoftDelete()) {\n  // ...\n}","searchable-fields#Searchable Fields":"The searchable fields feature allows you to define which fields can be searched in your models:\nDefine exact match fields (e.g., 'author_id')\nDefine partial match fields using the 'like:' prefix (e.g., 'like:title')\nAutomatically handles search queries in the CRUD index operation\nSupports multiple search criteria in a single query\nimport { BaseModel } from '@adonisjs/lucid/orm'\nimport { compose } from '@adonisjs/core/helpers'\nimport { withSoftDelete } from '@oniryk/dreamer/extensions/lucid'\nexport default class Post extends BaseModel {\n  public static searchable = ['author_id', 'like:title']\n}"}},"/extensions/output-formatters":{"title":"Output Formatters","data":{"output-formatters#Output formatters":"You may want to deliver a response in a specific file format like csv, as you can see in the index action from the CRUD abstraction extension.Dreamer has optional built-in formatters for csv and xlsx. You can install and use them as needed. They come in two separate packages: @oniryk/dreamer-csv and @oniryk/dreamer-xls.You can also create your own formatter. It must implement the following type:\ntype OutputFormatFn<M extends typeof BaseModel> = {\n  (ctx: HttpContext, rows: InstanceType<M>[]): Promise<void> | void\n  formatName: string\n}\nLet's create a new example formatter:\nexport default function pdf({ name }: { name: string }) {\n  const handler = async function ({ response }: HttpContext, rows: unknown[]) {\n    const content = await convertToPdf(rows); // imaginary function\n    response.header(\"Content-Type\", \"application/pdf\");\n    response.header(\"Content-Disposition\", `attachment; filename=\"${name}\"`);\n    response.send(content);\n  };\n  handler.formatName = \"pdf\";\n  return handler;\n}\nUsing our new formatter:\nexport default class PostsController {\n  public index = index(Post, {\n    formats: [\n      pdf({ name: 'posts.pdf' })\n    ]\n  })\n}"}},"/getting-started/installation":{"title":"Installation","data":{"installation#Installation":"node ace add @oniryk/dreamer\nAfter installing the package, you will be prompted with some questions and a dreamer config file will be generated like this:\nimport { defineConfig } from '@oniryk/dreamer'\nconst dreamerConfig = defineConfig({\n  useUUID: true,\n  useSoftDelete: true,\n  bruno: {\n    enabled: true,\n    documentsDir: '/docs',\n    useAuth: true,\n  },\n})\nexport default dreamerConfig","configuring#Configuring":"useUUID: when enabled, all models generated by the dreamer command will use uuid as field instead of id in the methods find() and findOrFail() from Lucid. learn more\nuseSoftDelete: when enabled, all models generated by the dreamer command will implement soft deletes. It will add the field deleted_at in the migration file. learn more\nbruno.enabled: when enabled, will generate bruno files for all routes generated by the dreamer command\nbruno.documentsDir: specifies where bruno's files will be placed\nbruno.useAuth: when enabled, will automatically add an Authorization: Bearer ... into the request file."}},"/":{"title":"What is dreamer?","data":{"":"@oniryk/dreamer is a collection of tools, developed under oniryk vision, that helps you build APIs with AdonisJS v6 faster and easier. It includes a code generator and a set of helper functions and abstractions to speed up your development workflow.What is included:\nA code generator that creates a full CRUD starting from a migration definition;\nAbstractions for CRUD actions;\nSupport for UUID as external ID;\nSupport for soft deletes;\nDefault formatting for API responses."}}}